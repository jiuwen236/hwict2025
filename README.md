# 2025 华为嵌入式软件大赛（算法组）亚军方案

## 项目简介
本仓库实现了“边缘集群 AI 推理的分布式任务调度”问题的高分解法，并以此获得 2025 华为嵌入式软件大赛（算法组）全国总决赛亚军。我们的队伍名是“gogogo出发”(京津东北赛区)。

给定多种服务器（每台服务器拥有若干 NPU、显存大小和推理速度系数）、多个用户在指定时间段内的推理请求，以及用户在不同服务器间的网络时延，目标是在 **30 秒** 的评测时限内输出一份调度方案以最大化官方评分函数。

---

## 算法总览
整体框架分为 **两条主干算法（方法一 & 方法二）+ 超参数搜索器**，程序在运行时自动挑选评分更高的方案作为最终输出。

### 1. 方法一：单 NPU 非并行启发式
1. **预估最佳 BatchSize**：针对每台服务器 / 每个用户，简单地二选一(显存允许的最大、或时间向下取整)以逼近最优吞吐量。
2. **逐用户调度**：按照预定义权重顺序从队列中取用户，遍历所有 NPU，计算“最早完成时间”并选择最优放置。
3. **延迟机制**：若预测完成时间超过 `e_i`，可将任务放入 `postponed` 队列稍后再调度。


### 2. 方法二：允许并行 + 迁移的多策略调度
方法二(`solve2`)是核心得分算法，支持在单 NPU 上同时跑多个 Batch，并允许用户请求在多 NPU 之间迁移。

1. **用户排序**  
   - 计算综合权重(用户会消耗的资源)，小权重先调度。
2. **NPU 状态建模**  
   - 使用 `freeAt[i][j][t]` 存储第 *i* 服务器第 *j* NPU 在第 *t* 毫秒剩余显存。
   - 使用 `parallel_cnt` 追踪并行度，辅助 BatchSize 规划。
3. **BatchSize 规划器**  
   - **DFS + 记忆化** (`get_bs_plan_cache`)：在 `(k,m,a,b)` 空间内搜索并缓存吞吐量最大的 `(bs[], time[])` 组合。
   - 允许显存不足时 **降级到更小 Batch**。
4. **调度策略**  
   - 支持 *顺序 / 逆序 / 随机 / 动态随机* 四种遍历顺序；
   - **削峰**：根据全局请求密度决定是否“反向时间轴”调度；
   - **受限迁移**：若首次放置失败，可启用带冷却期的迁移搜索。
5. **并行度控制**  
   - 每台服务器可设置 `max_parallel`，低负载时自动降低并行度以减少迁移。
6. 评分实时评估并回写结果。

### 3. 超参数搜索 (`solve`)
为适配不同数据，程序自动搜索方法二的 4 个离散超参。

搜索过程：
1. **初始化**：将手工经验配置放入队列；
2. **局部爬山**：单点替换，只要分数提升即接受；
3. **遗传随机搜索**：轮盘赌选父代 + 交叉 + 变异；
4. **提前停止**：基于平均 `solve2` 耗时预估下一次调用是否会超时。

---

## 关键点
* **理解题目**：题目核心在于降低用户的超时率，因为超时率对评分的影响是全局的。
* **提高理论吞吐量**：使用时间取整、DFS 或动态规划等方法提高理论吞吐量。
* **减少碎片**： (复赛后)保证发送时间的间隔是处理时间的整数倍。

---

## 比赛进程

### 初赛
有足够的练习赛时间。初赛具有固定的模型参数，我将所有时间的 BatchSize 预先计算好，这会获得比后续代码更高的理论吞吐量。但似乎由于线上数据与线下数据特征不同，我们的方法表现并不好。

### 复赛
复赛新增动态的 $a$、$b$，初赛的并行方法实现并不能有效处理，4个小时的比赛时间也不足以改出适配的方法。我们以赛区第3名勉强进入决赛。

### 决赛
我修改出适配的方法二并做了一些优化。决赛时新增的特性并不影响用户的超时率，可以忽略或使其小程度地影响排序权重。

---

## 其他
本仓库仅包含由我完成的代码。除了初赛、复赛和决赛的代码，还存放了非官方的判题器、数据生成器、数据、数据分析脚本、题目文档等。这些主要由 AI 生成。`main.cpp`的超参搜索、BatchSize 规划的具体代码也由 AI 完成。

---

## 致谢
感谢队友[李兴佳](https://github.com/Leest1022)和[王闯](https://github.com/wangchuangbrillant)。
感谢华为公司和华为光产品线举办本次比赛。